> ì¹´ë©”ë¼ë¥¼ í™œìš©í•œ ì‹¤ì‹œê°„ ë‹¹êµ¬ ìƒ· ë¶„ì„ ë° ì½”ì¹­ ì‹œìŠ¤í…œ

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Status](https://img.shields.io/badge/Status-alpha-orange)]()
[![Python](https://img.shields.io/badge/Python-3.8+-blue.svg)](https://www.python.org/)

---

## ğŸ“‹ í•œëˆˆì— ë³´ê¸°

- **ìƒíƒœ**: `alpha`
- **ë¼ì´ì„ ìŠ¤**: `MIT License`
- **ì–¸ì–´**: `Python 3.8+`
- **ì£¼ìš” ê¸°ëŠ¥**: `ì‹¤ì‹œê°„ ê³µ ì¶”ì , í ê°ë„ ë¶„ì„, ìµœì  ìƒ· ì¶”ì²œ, ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜`

---

## ğŸ¯ í”„ë¡œì íŠ¸ ì†Œê°œ

ë³¸ í”„ë¡œì íŠ¸ëŠ” ì¹´ë©”ë¼ë¥¼ í™œìš©í•˜ì—¬ ë‹¹êµ¬ëŒ€ ìœ„ì˜ ê³µê³¼ íì˜ ìœ„ì¹˜ ë° ê°ë„ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ì¶”ì í•˜ê³ , ë¬¼ë¦¬ ëª¨ë¸ ê¸°ë°˜ ì‹œë®¬ë ˆì´ì…˜ì„ í†µí•´ ìµœì ì˜ ìƒ· í›„ë³´ë¥¼ ì œì‹œí•˜ëŠ” ì˜¤í”ˆì†ŒìŠ¤ ì½”ì¹­ ì‹œìŠ¤í…œì…ë‹ˆë‹¤. 

ì‹œê°ì  ì˜¤ë²„ë ˆì´ë¡œ ì˜ˆìƒ ê²½ë¡œë¥¼ í‘œì‹œí•˜ë©°, í•™ìŠµìì˜ ì‹¤ë ¥ í–¥ìƒì„ ë•ëŠ” êµìœ¡ìš© ë„êµ¬ë¡œ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤. ëª¨ë“  ë°ì´í„°ëŠ” ë¡œì»¬ì—ì„œ ì²˜ë¦¬ë˜ì–´ í”„ë¼ì´ë²„ì‹œë¥¼ ë³´ì¥í•˜ê³ , ëª¨ë“ˆí™”ëœ êµ¬ì¡°ë¡œ ë‹¤ì–‘í•œ í”Œë«í¼ì— ì´ì‹ ê°€ëŠ¥í•©ë‹ˆë‹¤.

---

## ğŸ“š ëª©ì°¨

- [í•µì‹¬ íŠ¹ì§•](#-í•µì‹¬-íŠ¹ì§•)
- [ì„¤ì¹˜ ë°©ë²•](#-ì„¤ì¹˜-ë°©ë²•)
- [ë¹ ë¥¸ ì‹œì‘](#-ë¹ ë¥¸-ì‹œì‘)
- [ì‚¬ìš© ì˜ˆì œ](#-ì‚¬ìš©-ì˜ˆì œ)
- [í”„ë¡œì íŠ¸ êµ¬ì¡°](#-í”„ë¡œì íŠ¸-êµ¬ì¡°)
- [ëª¨ë“ˆë³„ ìƒì„¸ ì½”ë“œ](#-ëª¨ë“ˆë³„-ìƒì„¸-ì½”ë“œ)
- [ì•„í‚¤í…ì²˜](#-ì•„í‚¤í…ì²˜)
- [ê²°ê³¼ í™”ë©´ ì˜ˆì‹œ](#-ê²°ê³¼-í™”ë©´-ì˜ˆì‹œ)
- [ê°œë°œ ë¡œë“œë§µ](#-ê°œë°œ-ë¡œë“œë§µ)
- [ê¸°ì—¬í•˜ê¸°](#-ê¸°ì—¬í•˜ê¸°)
- [ë¼ì´ì„ ìŠ¤](#-ë¼ì´ì„ ìŠ¤)

---

## âœ¨ í•µì‹¬ íŠ¹ì§•

- **ì‹¤ì‹œê°„ ë¶„ì„**: 30-60fpsë¡œ ê³µì˜ ìœ„ì¹˜ì™€ íì˜ ê°ë„ë¥¼ ì¶”ì í•©ë‹ˆë‹¤
- **ë¬¼ë¦¬ ê¸°ë°˜ ì‹œë®¬ë ˆì´ì…˜**: ì¶©ëŒ, ë§ˆì°°, ì¿ ì…˜ ë°˜ì‚¬ë¥¼ ì •í™•íˆ ê³„ì‚°í•©ë‹ˆë‹¤
- **ì‹œê°ì  í”¼ë“œë°±**: ì˜ˆìƒ ê²½ë¡œì™€ ìµœì  íƒ€ì ì„ í™”ë©´ì— ì˜¤ë²„ë ˆì´ë¡œ í‘œì‹œí•©ë‹ˆë‹¤
- **ì‹¤íŒ¨ ì›ì¸ ë¶„ì„**: ë“ì  ì‹¤íŒ¨ ì‹œ ê³µì˜ ìµœì¢… ìœ„ì¹˜ë¥¼ ë¶„ì„í•˜ì—¬ ì‹¤íŒ¨ ì›ì¸ì„ ìë™ìœ¼ë¡œ ì§„ë‹¨í•˜ê³  ê°œì„  ë°©ì•ˆì„ ì œì‹œí•©ë‹ˆë‹¤
- **í”„ë¼ì´ë²„ì‹œ ìš°ì„ **: ëª¨ë“  ë°ì´í„°ëŠ” ë¡œì»¬ì—ì„œ ì²˜ë¦¬ë˜ë©°, ìµëª…í™” ì˜µì…˜ì„ ì œê³µí•©ë‹ˆë‹¤
- **ëª¨ë“ˆí™” ì„¤ê³„**: ì›¹/ë°ìŠ¤í¬íƒ‘/ëª¨ë°”ì¼ í™˜ê²½ì— ì‰½ê²Œ ì´ì‹ ê°€ëŠ¥í•©ë‹ˆë‹¤

---

## ğŸš€ ì„¤ì¹˜ ë°©ë²•

### ì‹œìŠ¤í…œ ìš”êµ¬ì‚¬í•­

- Python 3.8 ì´ìƒ
- pip ìµœì‹  ë²„ì „
- (ì„ íƒ) CUDA ì§€ì› GPU

### ì„¤ì¹˜

```bash
git clone https://github.com/your-username/billiard-coaching-system.git
cd billiard-coaching-system

# ê°€ìƒí™˜ê²½ ìƒì„± ë° í™œì„±í™” (Windows)
python -m venv venv
venv\Scripts\activate

# ê°€ìƒí™˜ê²½ ìƒì„± ë° í™œì„±í™” (Mac/Linux)
python3 -m venv venv
source venv/bin/activate

# ì˜ì¡´ì„± ì„¤ì¹˜
pip install -r requirements.txt
```

### requirements.txt

```txt
# ì»´í“¨í„° ë¹„ì „
opencv-python>=4.5.0
numpy>=1.20.0
scipy>=1.7.0

# ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜
matplotlib>=3.3.0

# ë°ì´í„° ì²˜ë¦¬
pandas>=1.3.0

# ë¡œê¹… ë° ì„¤ì •
python-dotenv>=0.19.0
pyyaml>=5.4.0

# í…ŒìŠ¤íŠ¸
pytest>=6.2.0
pytest-cov>=2.12.0
```

### í™˜ê²½ ì„¤ì •

í”„ë¡œì íŠ¸ ë£¨íŠ¸ì— `.env` íŒŒì¼ì„ ìƒì„±í•˜ê³  í•„ìš”í•œ ì„¤ì •ì„ ì…ë ¥í•©ë‹ˆë‹¤:

```env
CAMERA_ID=0
DEBUG_MODE=true
SAVE_LOGS=true
FPS_TARGET=30
```

---

## âš¡ ë¹ ë¥¸ ì‹œì‘

### MVP ì‹¤í–‰

```bash
# ë¹„ì „ ëª¨ë“ˆ í…ŒìŠ¤íŠ¸
python main.py --mode vision --input examples/sample_videos/test.mp4

# ì „ì²´ ì½”ì¹­ ì‹œìŠ¤í…œ ì‹¤í–‰
python main.py --mode full --camera 0
```

â¡ ì‹¤í–‰ í›„ OpenCV ìœˆë„ìš°ê°€ ì—´ë¦¬ë©° ì‹¤ì‹œê°„ ë¶„ì„ ê²°ê³¼ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

---

## ğŸ“– ì‚¬ìš© ì˜ˆì œ

### 1ï¸âƒ£ ë¹„ë””ì˜¤ íŒŒì¼ì—ì„œ ê³µ ì¶”ì 

```bash
python main.py --mode vision --input sample_video.mp4
```

### 2ï¸âƒ£ ì‹¤ì‹œê°„ ì¹´ë©”ë¼ë¡œ ìƒ· ì½”ì¹­

```bash
python main.py --mode full --camera 0
```

### 3ï¸âƒ£ ê²°ê³¼ í™•ì¸

- ì„ íƒëœ ìƒ· í›„ë³´ ë° ì˜ˆìƒ ê²½ë¡œê°€ í™”ë©´ì— ì˜¤ë²„ë ˆì´ë¡œ í‘œì‹œë©ë‹ˆë‹¤
- ìµœì  íƒ€ì ê³¼ í ê°ë„ í”¼ë“œë°±ì´ í…ìŠ¤íŠ¸ë¡œ ì œê³µë©ë‹ˆë‹¤
- **ë“ì  ì‹¤íŒ¨ ì‹œ** ê³µì˜ ìµœì¢… ìœ„ì¹˜ë¥¼ ë¶„ì„í•˜ì—¬ ì‹¤íŒ¨ ì›ì¸(ê°ë„ ì˜¤ì°¨, íŒŒì›Œ ë¶€ì¡±, ìŠ¤í•€ ê³¼ë‹¤ ë“±)ê³¼ ê°œì„  ë°©ì•ˆì„ ì œì‹œí•©ë‹ˆë‹¤
- ë¡œê·¸ëŠ” `logs/` í´ë”ì— ìë™ ì €ì¥ë©ë‹ˆë‹¤

### 4ï¸âƒ£ ì¢…ë£Œ ë°©ë²•

OpenCV ìœˆë„ìš°ì—ì„œ `q` í‚¤ë¥¼ ëˆ„ë¥´ê±°ë‚˜, í„°ë¯¸ë„ì—ì„œ `Ctrl + C` ì…ë ¥ í›„ ì¢…ë£Œ  
ê°€ìƒí™˜ê²½ ë¹„í™œì„±í™” â†’ `deactivate`

---

## ğŸ“ í”„ë¡œì íŠ¸ êµ¬ì¡°

```
billiard-coaching-system/
â”‚
â”œâ”€â”€ main.py                # ì§„ì…ì 
â”œâ”€â”€ requirements.txt       # Python ì˜ì¡´ì„±
â”œâ”€â”€ .env                   # í™˜ê²½ ë³€ìˆ˜
â”œâ”€â”€ config.yaml            # ì„¤ì • íŒŒì¼
â”‚
â”œâ”€â”€ vision/                # ë¹„ì „ ëª¨ë“ˆ
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ core.py           # ê³µ/í ê°ì§€
â”‚   â”œâ”€â”€ calibration.py    # ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜
â”‚   â””â”€â”€ tracking.py       # ê°ì²´ ì¶”ì 
â”‚
â”œâ”€â”€ physics/              # ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ engine.py         # ì‹œë®¬ë ˆì´ì…˜ ì—”ì§„
â”‚   â”œâ”€â”€ collision.py      # ì¶©ëŒ ì²˜ë¦¬
â”‚   â””â”€â”€ cushion.py        # ì¿ ì…˜ ë°˜ì‚¬
â”‚
â”œâ”€â”€ ranking/              # ìƒ· í‰ê°€ ì—”ì§„
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ score.py          # ì ìˆ˜ ê³„ì‚°
â”‚   â”œâ”€â”€ generator.py      # í›„ë³´ ìƒì„±
â”‚   â””â”€â”€ optimizer.py      # ìµœì í™”
â”‚
â”œâ”€â”€ feedback/             # í”¼ë“œë°± ì—”ì§„
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ overlay.py        # ì‹œê°ì  ì˜¤ë²„ë ˆì´
â”‚   â”œâ”€â”€ text.py           # í…ìŠ¤íŠ¸ ì„¤ëª…
â”‚   â””â”€â”€ failure_analyzer.py  # ì‹¤íŒ¨ ì›ì¸ ë¶„ì„
â”‚
â”œâ”€â”€ data/                 # ë°ì´í„° ê´€ë¦¬
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ storage.py        # ë¡œì»¬ ì €ì¥
â”‚   â””â”€â”€ privacy.py        # ìµëª…í™”
â”‚
â”œâ”€â”€ utils/                # ìœ í‹¸ë¦¬í‹°
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ logger.py         # ë¡œê¹…
â”‚   â””â”€â”€ config.py         # ì„¤ì • ë¡œë”
â”‚
â”œâ”€â”€ tests/                # í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_vision.py
â”‚   â”œâ”€â”€ test_physics.py
â”‚   â””â”€â”€ test_ranking.py
â”‚
â””â”€â”€ examples/             # ì˜ˆì œ
    â””â”€â”€ sample_videos/    # ìƒ˜í”Œ ë¹„ë””ì˜¤
```

---

## ğŸ’» ëª¨ë“ˆë³„ ìƒì„¸ ì½”ë“œ

### 1. main.py - ì§„ì…ì 

```python
"""
ë©”ì¸ ì‹¤í–‰ íŒŒì¼
"""
import argparse
import cv2
import numpy as np
from vision.core import BallDetector, CueDetector
from physics.engine import PhysicsEngine
from ranking.generator import ShotGenerator
from ranking.score import ShotScorer
from feedback.overlay import OverlayRenderer
from utils.logger import setup_logger
from utils.config import load_config

def main():
    parser = argparse.ArgumentParser(description='Billiard Shot Coaching System')
    parser.add_argument('--mode', choices=['vision', 'full'], default='full',
                        help='ì‹¤í–‰ ëª¨ë“œ ì„ íƒ')
    parser.add_argument('--camera', type=int, default=0,
                        help='ì¹´ë©”ë¼ ë””ë°”ì´ìŠ¤ ID')
    parser.add_argument('--input', type=str, default=None,
                        help='ì…ë ¥ ë¹„ë””ì˜¤ íŒŒì¼ ê²½ë¡œ')
    parser.add_argument('--config', type=str, default='config.yaml',
                        help='ì„¤ì • íŒŒì¼ ê²½ë¡œ')
    
    args = parser.parse_args()
    
    # ë¡œê±° ë° ì„¤ì • ë¡œë“œ
    logger = setup_logger()
    config = load_config(args.config)
    
    # ëª¨ë“ˆ ì´ˆê¸°í™”
    ball_detector = BallDetector(config['vision']['ball_detection'])
    cue_detector = CueDetector(config['vision']['cue_detection'])
    physics_engine = PhysicsEngine(config['physics'])
    shot_generator = ShotGenerator(config['ranking'])
    shot_scorer = ShotScorer(config['ranking'])
    overlay_renderer = OverlayRenderer()
    
    # ë¹„ë””ì˜¤ ì†ŒìŠ¤ ì„¤ì •
    if args.input:
        cap = cv2.VideoCapture(args.input)
    else:
        cap = cv2.VideoCapture(args.camera)
    
    logger.info(f"ì‹œìŠ¤í…œ ì‹œì‘ - ëª¨ë“œ: {args.mode}")
    
    while True:
        ret, frame = cap.read()
        if not ret:
            break
        
        # 1. ê³µ ê°ì§€
        balls = ball_detector.detect(frame)
        
        if args.mode == 'full' and len(balls) > 0:
            # 2. í ê°ì§€
            cue = cue_detector.detect(frame, balls)
            
            # 3. ìƒ· í›„ë³´ ìƒì„±
            candidates = shot_generator.generate(balls, cue)
            
            # 4. ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ë° ì ìˆ˜ ê³„ì‚°
            best_shot = None
            best_score = -1
            
            for candidate in candidates[:10]:  # ìƒìœ„ 10ê°œë§Œ ì‹œë®¬ë ˆì´ì…˜
                result = physics_engine.simulate(balls, candidate)
                score = shot_scorer.score(result, candidate)
                
                if score > best_score:
                    best_score = score
                    best_shot = (candidate, result)
            
            # 5. ì‹œê°ì  í”¼ë“œë°±
            if best_shot:
                frame = overlay_renderer.render(frame, balls, cue, best_shot)
        else:
            # Vision ëª¨ë“œ: ê³µë§Œ í‘œì‹œ
            frame = overlay_renderer.render_balls(frame, balls)
        
        # í™”ë©´ í‘œì‹œ
        cv2.imshow('Billiard Coaching System', frame)
        
        # 'q' í‚¤ë¡œ ì¢…ë£Œ
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
    
    cap.release()
    cv2.destroyAllWindows()
    logger.info("ì‹œìŠ¤í…œ ì¢…ë£Œ")

if __name__ == '__main__':
    main()
```

---

### 2. vision/core.py - ê³µ/í ê°ì§€

```python
"""
ë¹„ì „ ëª¨ë“ˆ: ê³µê³¼ í ê°ì§€
"""
import cv2
import numpy as np

class BallDetector:
    """ë‹¹êµ¬ê³µ ê°ì§€ í´ë˜ìŠ¤"""
    
    def __init__(self, config):
        self.min_radius = config.get('min_radius', 5)
        self.max_radius = config.get('max_radius', 30)
        self.confidence_threshold = config.get('confidence_threshold', 0.7)
    
    def detect(self, frame):
        """
        í”„ë ˆì„ì—ì„œ ë‹¹êµ¬ê³µì„ ê°ì§€í•©ë‹ˆë‹¤.
        
        Args:
            frame: ì…ë ¥ ì´ë¯¸ì§€ (BGR)
        
        Returns:
            balls: ê°ì§€ëœ ê³µ ë¦¬ìŠ¤íŠ¸ [{'x': int, 'y': int, 'r': int, 'color': str}, ...]
        """
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        blurred = cv2.medianBlur(gray, 5)
        
        # Hough Circle Transformìœ¼ë¡œ ì› ê°ì§€
        circles = cv2.HoughCircles(
            blurred,
            cv2.HOUGH_GRADIENT,
            dp=1.2,
            minDist=20,
            param1=50,
            param2=30,
            minRadius=self.min_radius,
            maxRadius=self.max_radius
        )
        
        balls = []
        if circles is not None:
            circles = np.uint16(np.around(circles))
            for circle in circles[0, :]:
                x, y, r = circle
                
                # ìƒ‰ìƒ ë¶„ì„
                color = self._analyze_color(frame, x, y, r)
                
                balls.append({
                    'x': int(x),
                    'y': int(y),
                    'r': int(r),
                    'color': color
                })
        
        return balls
    
    def _analyze_color(self, frame, x, y, r):
        """ê³µì˜ ìƒ‰ìƒì„ ë¶„ì„í•©ë‹ˆë‹¤."""
        # ROI ì¶”ì¶œ
        mask = np.zeros(frame.shape[:2], dtype=np.uint8)
        cv2.circle(mask, (x, y), r, 255, -1)
        
        mean_color = cv2.mean(frame, mask=mask)[:3]
        b, g, r = mean_color
        
        # ê°„ë‹¨í•œ ìƒ‰ìƒ ë¶„ë¥˜
        if r > 150 and g < 100 and b < 100:
            return 'red'
        elif r < 100 and g < 100 and b > 150:
            return 'blue'
        elif r > 200 and g > 200 and b > 200:
            return 'white'
        else:
            return 'other'


class CueDetector:
    """í ê°ì§€ í´ë˜ìŠ¤"""
    
    def __init__(self, config):
        self.min_length = config.get('min_length', 50)
        self.angle_tolerance = config.get('angle_tolerance', 5)
    
    def detect(self, frame, balls):
        """
        í”„ë ˆì„ì—ì„œ íë¥¼ ê°ì§€í•©ë‹ˆë‹¤.
        
        Args:
            frame: ì…ë ¥ ì´ë¯¸ì§€ (BGR)
            balls: ê°ì§€ëœ ê³µ ë¦¬ìŠ¤íŠ¸
        
        Returns:
            cue: í ì •ë³´ {'start': (x1, y1), 'end': (x2, y2), 'angle': float} ë˜ëŠ” None
        """
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        edges = cv2.Canny(gray, 50, 150, apertureSize=3)
        
        # Hough Line Transformìœ¼ë¡œ ì§ì„  ê°ì§€
        lines = cv2.HoughLinesP(
            edges,
            rho=1,
            theta=np.pi/180,
            threshold=100,
            minLineLength=self.min_length,
            maxLineGap=10
        )
        
        if lines is None:
            return None
        
        # ê°€ì¥ ê¸´ ì„ ì„ íë¡œ ê°„ì£¼
        longest_line = None
        max_length = 0
        
        for line in lines:
            x1, y1, x2, y2 = line[0]
            length = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
            
            if length > max_length:
                max_length = length
                longest_line = line[0]
        
        if longest_line is not None:
            x1, y1, x2, y2 = longest_line
            angle = np.arctan2(y2 - y1, x2 - x1) * 180 / np.pi
            
            return {
                'start': (x1, y1),
                'end': (x2, y2),
                'angle': angle
            }
        
        return None
```

---

### 3. physics/engine.py - ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜

```python
"""
ë¬¼ë¦¬ ì—”ì§„: ë‹¹êµ¬ê³µ ì¶©ëŒ ë° ê²½ë¡œ ì‹œë®¬ë ˆì´ì…˜
"""
import numpy as np

class Ball:
    """ë‹¹êµ¬ê³µ ê°ì²´"""
    
    def __init__(self, x, y, vx=0, vy=0, r=2.25, m=0.17):
        self.x = x
        self.y = y
        self.vx = vx
        self.vy = vy
        self.r = r
        self.m = m


class PhysicsEngine:
    """ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì—”ì§„"""
    
    def __init__(self, config):
        self.friction = config.get('friction_coefficient', 0.02)
        self.restitution = config.get('restitution', 0.95)
        self.dt = config.get('time_delta', 0.001)
        self.max_steps = config.get('simulation_steps', 1000)
        self.table_width = config.get('table_width', 254)  # cm
        self.table_height = config.get('table_height', 127)  # cm
    
    def simulate(self, balls_data, shot_candidate):
        """
        ìƒ·ì„ ì‹œë®¬ë ˆì´ì…˜í•©ë‹ˆë‹¤.
        
        Args:
            balls_data: ê°ì§€ëœ ê³µ ë¦¬ìŠ¤íŠ¸
            shot_candidate: ìƒ· í›„ë³´ {'cue_ball': int, 'direction': (vx, vy), 'power': float}
        
        Returns:
            result: ì‹œë®¬ë ˆì´ì…˜ ê²°ê³¼ {'path': [...], 'success': bool, 'collisions': [...]}
        """
        # Ball ê°ì²´ ìƒì„±
        balls = []
        for b in balls_data:
            balls.append(Ball(b['x'], b['y'], 0, 0, b['r']))
        
        # íë³¼ì— ì´ˆê¸° ì†ë„ ë¶€ì—¬
        cue_idx = shot_candidate['cue_ball']
        direction = shot_candidate['direction']
        power = shot_candidate['power']
        
        balls[cue_idx].vx = direction[0] * power
        balls[cue_idx].vy = direction[1] * power
        
        # ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰
        path = []
        collisions = []
        
        for step in range(self.max_steps):
            # ëª¨ë“  ê³µ ì—…ë°ì´íŠ¸
            for ball in balls:
                self._update_ball(ball)
            
            # ì¶©ëŒ ê°ì§€ ë° ì²˜ë¦¬
            for i in range(len(balls)):
                for j in range(i + 1, len(balls)):
                    if self._check_collision(balls[i], balls[j]):
                        self._resolve_collision(balls[i], balls[j])
                        collisions.append((i, j, step * self.dt))
            
            # ê²½ë¡œ ê¸°ë¡ (íë³¼ë§Œ)
            path.append((balls[cue_idx].x, balls[cue_idx].y))
            
            # ëª¨ë“  ê³µì´ ì •ì§€í•˜ë©´ ì¢…ë£Œ
            if self._all_stopped(balls):
                break
        
        return {
            'path': path,
            'success': len(collisions) > 0,
            'collisions': collisions,
            'final_positions': [(b.x, b.y) for b in balls]
        }
    
    def _update_ball(self, ball):
        """ê³µì˜ ìœ„ì¹˜ì™€ ì†ë„ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤."""
        # ë§ˆì°° ì ìš©
        speed = np.sqrt(ball.vx**2 + ball.vy**2)
        if speed > 0:
            friction_force = self.friction * self.dt
            ball.vx *= max(0, 1 - friction_force / speed)
            ball.vy *= max(0, 1 - friction_force / speed)
        
        # ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        ball.x += ball.vx * self.dt
        ball.y += ball.vy * self.dt
        
        # ë²½ ì¶©ëŒ ì²˜ë¦¬
        if ball.x - ball.r <= 0 or ball.x + ball.r >= self.table_width:
            ball.vx *= -self.restitution
            ball.x = np.clip(ball.x, ball.r, self.table_width - ball.r)
        
        if ball.y - ball.r <= 0 or ball.y + ball.r >= self.table_height:
            ball.vy *= -self.restitution
            ball.y = np.clip(ball.y, ball.r, self.table_height - ball.r)
    
    def _check_collision(self, ball1, ball2):
        """ë‘ ê³µì˜ ì¶©ëŒ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤."""
        dx = ball2.x - ball1.x
        dy = ball2.y - ball1.y
        distance = np.sqrt(dx**2 + dy**2)
        return distance <= (ball1.r + ball2.r)
    
    def _resolve_collision(self, ball1, ball2):
        """ë‘ ê³µì˜ ì¶©ëŒì„ ì²˜ë¦¬í•©ë‹ˆë‹¤."""
        # ì¶©ëŒ ë²¡í„°
        dx = ball2.x - ball1.x
        dy = ball2.y - ball1.y
        distance = np.sqrt(dx**2 + dy**2)
        
        if distance == 0:
            return
        
        # ì •ê·œí™”ëœ ì¶©ëŒ ë²¡í„°
        nx = dx / distance
        ny = dy / distance
        
        # ìƒëŒ€ ì†ë„
        dvx = ball1.vx - ball2.vx
        dvy = ball1.vy - ball2.vy
        
        # ì¶©ëŒ ì¶• ë°©í–¥ ìƒëŒ€ ì†ë„
        dvn = dvx * nx + dvy * ny
        
        # ì´ë¯¸ ë©€ì–´ì§€ê³  ìˆìœ¼ë©´ ë¬´ì‹œ
        if dvn <= 0:
            return
        
        # ì¶©ê²©ëŸ‰ ê³„ì‚°
        impulse = 2 * dvn / (ball1.m + ball2.m)
        
        # ì†ë„ ì—…ë°ì´íŠ¸
        ball1.vx -= impulse * ball2.m * nx
        ball1.vy -= impulse * ball2.m * ny
        ball2.vx += impulse * ball1.m * nx
        ball2.vy += impulse * ball1.m * ny
    
    def _all_stopped(self, balls):
        """ëª¨ë“  ê³µì´ ì •ì§€í–ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
        threshold = 0.01
        for ball in balls:
            if np.sqrt(ball.vx**2 + ball.vy**2) > threshold:
                return False
        return True
```

---

### 4. ranking/generator.py - ìƒ· í›„ë³´ ìƒì„±

```python
"""
ìƒ· í›„ë³´ ìƒì„±ê¸°
"""
import numpy as np

class ShotGenerator:
    """ìƒ· í›„ë³´ ìƒì„± í´ë˜ìŠ¤"""
    
    def __init__(self, config):
        self.angle_resolution = config.get('angle_resolution', 15)  # ê°ë„ í•´ìƒë„(ë„)
        self.power_levels = config.get('power_levels', [0.3, 0.5, 0.7, 1.0])
    
    def generate(self, balls, cue):
        """
        ê°€ëŠ¥í•œ ìƒ· í›„ë³´ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
        
        Args:
            balls: ê°ì§€ëœ ê³µ ë¦¬ìŠ¤íŠ¸
            cue: í ì •ë³´
        
        Returns:
            candidates: ìƒ· í›„ë³´ ë¦¬ìŠ¤íŠ¸
        """
        candidates = []
        
        # í° ê³µ(íë³¼) ì°¾ê¸°
        cue_ball_idx = None
        for i, ball in enumerate(balls):
            if ball['color'] == 'white':
                cue_ball_idx = i
                break
        
        if cue_ball_idx is None:
            return candidates
        
        cue_ball = balls[cue_ball_idx]
        
        # ëª¨ë“  ê°ë„ì™€ íŒŒì›Œ ì¡°í•© ìƒì„±
        for angle_deg in range(0, 360, self.angle_resolution):
            angle_rad = np.deg2rad(angle_deg)
            direction = (np.cos(angle_rad), np.sin(angle_rad))
            
            for power in self.power_levels:
                candidate = {
                    'cue_ball': cue_ball_idx,
                    'direction': direction,
                    'power': power,
                    'angle': angle_deg
                }
                candidates.append(candidate)
        
        return candidates
```

---

### 5. ranking/score.py - ìƒ· ì ìˆ˜ ê³„ì‚°

```python
"""
ìƒ· í‰ê°€ ë° ì ìˆ˜ ê³„ì‚°
"""
import numpy as np

class ShotScorer:
    """ìƒ· ì ìˆ˜ ê³„ì‚° í´ë˜ìŠ¤"""
    
    def __init__(self, config):
        self.weights = config.get('weights', {
            'collision': 0.5,
            'accuracy': 0.3,
            'safety': 0.2
        })
    
    def score(self, simulation_result, candidate):
        """
        ìƒ·ì˜ ì ìˆ˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
        
        Args:
            simulation_result: ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ê²°ê³¼
            candidate: ìƒ· í›„ë³´
        
        Returns:
            score: ì ìˆ˜ (0.0 ~ 1.0)
        """
        collision_score = self._score_collision(simulation_result)
        accuracy_score = self._score_accuracy(simulation_result)
        safety_score = self._score_safety(simulation_result)
        
        total_score = (
            self.weights['collision'] * collision_score +
            self.weights['accuracy'] * accuracy_score +
            self.weights['safety'] * safety_score
        )
        
        return total_score
    
    def _score_collision(self, result):
        """ì¶©ëŒ ì„±ê³µ ì—¬ë¶€ ì ìˆ˜"""
        return 1.0 if result['success'] else 0.0
    
    def _score_accuracy(self, result):
        """ì •í™•ë„ ì ìˆ˜ (ê²½ë¡œ ê¸¸ì´ ê¸°ë°˜)"""
        path = result['path']
        if len(path) < 2:
            return 0.0
        
        # ê²½ë¡œê°€ ì§§ì„ìˆ˜ë¡ ë†’ì€ ì ìˆ˜
        path_length = 0
        for i in range(1, len(path)):
            dx = path[i][0] - path[i-1][0]
            dy = path[i][1] - path[i-1][1]
            path_length += np.sqrt(dx**2 + dy**2)
        
        # ì •ê·œí™” (ì„ì˜ì˜ ìµœëŒ€ê°’ ì‚¬ìš©)
        max_length = 500
        return max(0.0, 1.0 - path_length / max_length)
    
    def _score_safety(self, result):
        """ì•ˆì „ì„± ì ìˆ˜ (ë²½ ê·¼ì ‘ë„)"""
        final_pos = result['final_positions'][0]  # íë³¼ ìµœì¢… ìœ„ì¹˜
        
        # í…Œì´ë¸” ì¤‘ì•™ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬
        center_x, center_y = 127, 63.5  # í…Œì´ë¸” ì¤‘ì‹¬
        distance = np.sqrt((final_pos[0] - center_x)**2 + (final_pos[1] - center_y)**2)
        
        # ì •ê·œí™”
        max_distance = np.sqrt(center_x**2 + center_y**2)
        return 1.0 - distance / max_distance
```

---

### 6. feedback/overlay.py - ì‹œê°ì  ì˜¤ë²„ë ˆì´

```python
"""
ì‹œê°ì  í”¼ë“œë°± ì˜¤ë²„ë ˆì´
"""
import cv2
import numpy as np

class OverlayRenderer:
    """ì‹œê°ì  ì˜¤ë²„ë ˆì´ ë Œë”ë§ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.colors = {
            'white': (255, 255, 255),
            'red': (0, 0, 255),
            'blue': (255, 0, 0),
            'other': (0, 255, 0)
        }
    
    def render(self, frame, balls, cue, best_shot):
        """
        ì „ì²´ í”¼ë“œë°±ì„ ë Œë”ë§í•©ë‹ˆë‹¤.
        
        Args:
            frame: ì…ë ¥ í”„ë ˆì„
            balls: ê°ì§€ëœ ê³µ ë¦¬ìŠ¤íŠ¸
            cue: í ì •ë³´
            best_shot: ìµœì  ìƒ· (candidate, result)
        
        Returns:
            frame: ì˜¤ë²„ë ˆì´ê°€ ê·¸ë ¤ì§„ í”„ë ˆì„
        """
        overlay = frame.copy()
        
        # 1. ê³µ í‘œì‹œ
        for ball in balls:
            color = self.colors.get(ball['color'], (0, 255, 0))
            cv2.circle(overlay, (ball['x'], ball['y']), ball['r'], color, 2)
            cv2.circle(overlay, (ball['x'], ball['y']), 2, color, -1)
        
        # 2. ìµœì  ìƒ· ê²½ë¡œ í‘œì‹œ
        if best_shot:
            candidate, result = best_shot
            path = result['path']
            
            # ê²½ë¡œ ì„  ê·¸ë¦¬ê¸°
            for i in range(1, len(path)):
                pt1 = (int(path[i-1][0]), int(path[i-1][1]))
                pt2 = (int(path[i][0]), int(path[i][1]))
                cv2.line(overlay, pt1, pt2, (0, 255, 255), 2)
            
            # ì¶©ëŒ ì§€ì  í‘œì‹œ
            for collision in result['collisions']:
                idx1, idx2, time = collision
                if len(path) > 0:
                    pos_idx = min(int(time * 1000), len(path) - 1)
                    pos = path[pos_idx]
                    cv2.circle(overlay, (int(pos[0]), int(pos[1])), 8, (0, 0, 255), -1)
            
            # ìƒ· ì •ë³´ í…ìŠ¤íŠ¸
            angle = candidate['angle']
            power = candidate['power']
            text = f"Angle: {angle:.1f}Â° | Power: {power:.2f}"
            cv2.putText(overlay, text, (10, 30), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
        
        # 3. í í‘œì‹œ
        if cue:
            cv2.line(overlay, cue['start'], cue['end'], (255, 0, 255), 3)
        
        return overlay
    
    def render_balls(self, frame, balls):
        """ê³µë§Œ í‘œì‹œí•©ë‹ˆë‹¤."""
        overlay = frame.copy()
        
        for ball in balls:
            color = self.colors.get(ball['color'], (0, 255, 0))
            cv2.circle(overlay, (ball['x'], ball['y']), ball['r'], color, 2)
            cv2.circle(overlay, (ball['x'], ball['y']), 2, color, -1)
        
        return overlay
```

---

### 7. utils/logger.py - ë¡œê¹… ì„¤ì •

```python
"""
ë¡œê¹… ìœ í‹¸ë¦¬í‹°
"""
import logging
import os
from datetime import datetime

def setup_logger(name='BilliardCoach', log_dir='logs'):
    """
    ë¡œê±°ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
    
    Args:
        name: ë¡œê±° ì´ë¦„
        log_dir: ë¡œê·¸ ë””ë ‰í† ë¦¬
    
    Returns:
        logger: ì„¤ì •ëœ ë¡œê±°
    """
    # ë¡œê·¸ ë””ë ‰í† ë¦¬ ìƒì„±
    os.makedirs(log_dir, exist_ok=True)
    
    # ë¡œê±° ìƒì„±
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    
    # ì´ë¯¸ í•¸ë“¤ëŸ¬ê°€ ìˆìœ¼ë©´ ì œê±°
    if logger.handlers:
        logger.handlers.clear()
    
    # íŒŒì¼ í•¸ë“¤ëŸ¬
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    file_handler = logging.FileHandler(
        os.path.join(log_dir, f'billiard_{timestamp}.log'),
        encoding='utf-8'
    )
    file_handler.setLevel(logging.DEBUG)
    
    # ì½˜ì†” í•¸ë“¤ëŸ¬
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    
    # í¬ë§· ì„¤ì •
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    # í•¸ë“¤ëŸ¬ ì¶”ê°€
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    return logger
```

---

### 8. utils/config.py - ì„¤ì • ë¡œë”

```python
"""
ì„¤ì • íŒŒì¼ ë¡œë”
"""
import yaml
import os

def load_config(config_path='config.yaml'):
    """
    YAML ì„¤ì • íŒŒì¼ì„ ë¡œë“œí•©ë‹ˆë‹¤.
    
    Args:
        config_path: ì„¤ì • íŒŒì¼ ê²½ë¡œ
    
    Returns:
        config: ì„¤ì • ë”•ì…”ë„ˆë¦¬
    """
    if not os.path.exists(config_path):
        # ê¸°ë³¸ ì„¤ì • ë°˜í™˜
        return get_default_config()
    
    with open(config_path, 'r', encoding='utf-8') as f:
        config = yaml.safe_load(f)
    
    return config

def get_default_config():
    """ê¸°ë³¸ ì„¤ì •ì„ ë°˜í™˜í•©ë‹ˆë‹¤."""
    return {
        'vision': {
            'ball_detection': {
                'min_radius': 5,
                'max_radius': 30,
                'confidence_threshold': 0.7
            },
            'cue_detection': {
                'min_length': 50,
                'angle_tolerance': 5
            }
        },
        'physics': {
            'friction_coefficient': 0.02,
            'restitution': 0.95,
            'simulation_steps': 1000,
            'time_delta': 0.001,
            'table_width': 254,
            'table_height': 127
        },
        'ranking': {
            'angle_resolution': 15,
            'power_levels': [0.3, 0.5, 0.7, 1.0],
            'weights': {
                'collision': 0.5,
                'accuracy': 0.3,
                'safety': 0.2
            }
        }
    }
```

---

### 9. config.yaml - ì„¤ì • íŒŒì¼

```yaml
vision:
  ball_detection:
    min_radius: 5
    max_radius: 30
    confidence_threshold: 0.7
  
  cue_detection:
    min_length: 50
    angle_tolerance: 5

physics:
  friction_coefficient: 0.02
  restitution: 0.95
  simulation_steps: 1000
  time_delta: 0.001
  table_width: 254
  table_height: 127

ranking:
  angle_resolution: 15
  power_levels: [0.3, 0.5, 0.7, 1.0]
  weights:
    collision: 0.5
    accuracy: 0.3
    safety: 0.2
```

---

### 10. data/storage.py - ë°ì´í„° ì €ì¥

```python
"""
ë°ì´í„° ì €ì¥ ë° ê´€ë¦¬
"""
import sqlite3
import json
import os
from datetime import datetime

class DataStorage:
    """ë¡œì»¬ ë°ì´í„° ì €ì¥ì†Œ"""
    
    def __init__(self, db_path='data/billiard.db'):
        """
        ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        
        Args:
            db_path: ë°ì´í„°ë² ì´ìŠ¤ íŒŒì¼ ê²½ë¡œ
        """
        os.makedirs(os.path.dirname(db_path), exist_ok=True)
        self.db_path = db_path
        self._init_db()
    
    def _init_db(self):
        """ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸”ì„ ìƒì„±í•©ë‹ˆë‹¤."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS shots (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                balls_data TEXT NOT NULL,
                shot_candidate TEXT NOT NULL,
                simulation_result TEXT NOT NULL,
                score REAL NOT NULL
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                start_time TEXT NOT NULL,
                end_time TEXT,
                total_shots INTEGER DEFAULT 0
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def save_shot(self, balls_data, shot_candidate, simulation_result, score):
        """
        ìƒ· ë°ì´í„°ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
        
        Args:
            balls_data: ê³µ ë°ì´í„°
            shot_candidate: ìƒ· í›„ë³´
            simulation_result: ì‹œë®¬ë ˆì´ì…˜ ê²°ê³¼
            score: ì ìˆ˜
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        timestamp = datetime.now().isoformat()
        
        cursor.execute('''
            INSERT INTO shots (timestamp, balls_data, shot_candidate, simulation_result, score)
            VALUES (?, ?, ?, ?, ?)
        ''', (
            timestamp,
            json.dumps(balls_data),
            json.dumps(shot_candidate),
            json.dumps(simulation_result),
            score
        ))
        
        conn.commit()
        conn.close()
    
    def get_recent_shots(self, limit=10):
        """ìµœê·¼ ìƒ· ê¸°ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT * FROM shots
            ORDER BY timestamp DESC
            LIMIT ?
        ''', (limit,))
        
        rows = cursor.fetchall()
        conn.close()
        
        return rows
```

---

### 11. data/privacy.py - ë°ì´í„° ìµëª…í™”

```python
"""
í”„ë¼ì´ë²„ì‹œ ë° ë°ì´í„° ìµëª…í™”
"""
import hashlib
import json

class PrivacyManager:
    """ë°ì´í„° í”„ë¼ì´ë²„ì‹œ ê´€ë¦¬ì"""
    
    def __init__(self):
        self.anonymize_enabled = True
    
    def anonymize_data(self, data):
        """
        ë°ì´í„°ë¥¼ ìµëª…í™”í•©ë‹ˆë‹¤.
        
        Args:
            data: ì›ë³¸ ë°ì´í„°
        
        Returns:
            anonymized_data: ìµëª…í™”ëœ ë°ì´í„°
        """
        if not self.anonymize_enabled:
            return data
        
        anonymized = data.copy()
        
        # ìœ„ì¹˜ ì •ë³´ í•´ì‹±
        if 'balls' in anonymized:
            for ball in anonymized['balls']:
                ball['x'] = self._hash_value(ball['x'])
                ball['y'] = self._hash_value(ball['y'])
        
        return anonymized
    
    def _hash_value(self, value):
        """ê°’ì„ í•´ì‹œí™”í•©ë‹ˆë‹¤."""
        hash_object = hashlib.sha256(str(value).encode())
        return hash_object.hexdigest()[:8]
```

---

### 12. tests/test_vision.py - ë¹„ì „ ëª¨ë“ˆ í…ŒìŠ¤íŠ¸

```python
"""
ë¹„ì „ ëª¨ë“ˆ í…ŒìŠ¤íŠ¸
"""
import pytest
import numpy as np
import cv2
from vision.core import BallDetector, CueDetector

def test_ball_detector():
    """ê³µ ê°ì§€ í…ŒìŠ¤íŠ¸"""
    config = {
        'min_radius': 5,
        'max_radius': 30,
        'confidence_threshold': 0.7
    }
    
    detector = BallDetector(config)
    
    # í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ ìƒì„± (í° ê³µ í•˜ë‚˜)
    frame = np.zeros((480, 640, 3), dtype=np.uint8)
    cv2.circle(frame, (320, 240), 20, (255, 255, 255), -1)
    
    balls = detector.detect(frame)
    
    assert len(balls) > 0
    assert balls[0]['color'] == 'white'

def test_cue_detector():
    """í ê°ì§€ í…ŒìŠ¤íŠ¸"""
    config = {
        'min_length': 50,
        'angle_tolerance': 5
    }
    
    detector = CueDetector(config)
    
    # í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ ìƒì„± (ì§ì„ )
    frame = np.zeros((480, 640, 3), dtype=np.uint8)
    cv2.line(frame, (100, 100), (500, 300), (255, 255, 255), 5)
    
    balls = []
    cue = detector.detect(frame, balls)
    
    # íê°€ ê°ì§€ë˜ì–´ì•¼ í•¨
    assert cue is not None
```

---

### 13. tests/test_physics.py - ë¬¼ë¦¬ ì—”ì§„ í…ŒìŠ¤íŠ¸

```python
"""
ë¬¼ë¦¬ ì—”ì§„ í…ŒìŠ¤íŠ¸
"""
import pytest
from physics.engine import PhysicsEngine, Ball

def test_physics_engine():
    """ë¬¼ë¦¬ ì—”ì§„ ê¸°ë³¸ í…ŒìŠ¤íŠ¸"""
    config = {
        'friction_coefficient': 0.02,
        'restitution': 0.95,
        'simulation_steps': 100,
        'time_delta': 0.01,
        'table_width': 254,
        'table_height': 127
    }
    
    engine = PhysicsEngine(config)
    
    # í…ŒìŠ¤íŠ¸ ë°ì´í„°
    balls_data = [
        {'x': 50, 'y': 50, 'r': 10, 'color': 'white'},
        {'x': 150, 'y': 150, 'r': 10, 'color': 'red'}
    ]
    
    shot_candidate = {
        'cue_ball': 0,
        'direction': (1.0, 0.0),
        'power': 50.0
    }
    
    result = engine.simulate(balls_data, shot_candidate)
    
    assert 'path' in result
    assert 'success' in result
    assert len(result['path']) > 0
```
### 15. feedback/text.py - í…ìŠ¤íŠ¸ í”¼ë“œë°± ìƒì„± (ì˜ì‚¬ì½”ë“œ)

```python
"""
í…ìŠ¤íŠ¸ ê¸°ë°˜ í”¼ë“œë°± ìƒì„± - ì•Œê³ ë¦¬ì¦˜ë§Œ ì œì‹œ
"""

class TextFeedbackGenerator:
    """í…ìŠ¤íŠ¸ í”¼ë“œë°± ìƒì„±ê¸°"""
    
    def generate_success_feedback(self, shot_result):
        """
        ì„±ê³µ ì‹œ í”¼ë“œë°± ìƒì„±
        
        ì•Œê³ ë¦¬ì¦˜:
        1. ìƒ·ì˜ ì •í™•ë„ ì ìˆ˜ ê³„ì‚° (0-100%)
        2. ìš°ìˆ˜í•œ ë¶€ë¶„ ì‹ë³„ (ê°ë„, íŒŒì›Œ, íƒ€ì´ë°)
        3. ì¹­ì°¬ ë©”ì‹œì§€ ìƒì„±
        4. ë‹¤ìŒ ë‹¨ê³„ ì œì•ˆ
        """
        pass
    
    def generate_failure_feedback(self, analysis_result):
        """
        ì‹¤íŒ¨ ì‹œ í”¼ë“œë°± ìƒì„±
        
        ì•Œê³ ë¦¬ì¦˜:
        1. FailureAnalyzerì˜ ë¶„ì„ ê²°ê³¼ ìˆ˜ì‹ 
        2. ì£¼ìš” ì›ì¸ì„ ì‚¬ìš©ì ì¹œí™”ì  ì–¸ì–´ë¡œ ë³€í™˜
        3. ë‹¨ê³„ë³„ ê°œì„  ê°€ì´ë“œ ìƒì„±
        4. ê´€ë ¨ ì—°ìŠµ ë°©ë²• ì œì•ˆ
        """
        pass
    
    def generate_progress_feedback(self, history):
        """
        ì§„í–‰ ìƒí™© í”¼ë“œë°±
        
        ì•Œê³ ë¦¬ì¦˜:
        1. ìµœê·¼ Nê°œ ìƒ·ì˜ í†µê³„ ë¶„ì„
        2. í–¥ìƒëœ ë¶€ë¶„ê³¼ ì •ì²´ëœ ë¶€ë¶„ ì‹ë³„
        3. ì„±ì·¨ë„ ë¦¬í¬íŠ¸ ìƒì„±
        4. ë§ì¶¤í˜• ì—°ìŠµ ê³„íš ì œì•ˆ
        """
        pass
```

---

### 16. main.py ì—…ë°ì´íŠ¸ - ì‹¤íŒ¨ ë¶„ì„ í†µí•© (ì™„ì „ êµ¬í˜„)

```python
"""
ë©”ì¸ ì‹¤í–‰ íŒŒì¼ - ì‹¤íŒ¨ ë¶„ì„ ê¸°ëŠ¥ ì¶”ê°€
"""
import argparse
import cv2
import numpy as np
from vision.core import BallDetector, CueDetector
from physics.engine import PhysicsEngine
from ranking.generator import ShotGenerator
from ranking.score import ShotScorer
from feedback.overlay import OverlayRenderer
from feedback.failure_analyzer import FailureAnalyzer  # ì¶”ê°€
from utils.logger import setup_logger
from utils.config import load_config

def main():
    parser = argparse.ArgumentParser(description='Billiard Shot Coaching System')
    parser.add_argument('--mode', choices=['vision', 'full', 'practice'], default='full',
                        help='ì‹¤í–‰ ëª¨ë“œ ì„ íƒ')
    parser.add_argument('--camera', type=int, default=0,
                        help='ì¹´ë©”ë¼ ë””ë°”ì´ìŠ¤ ID')
    parser.add_argument('--input', type=str, default=None,
                        help='ì…ë ¥ ë¹„ë””ì˜¤ íŒŒì¼ ê²½ë¡œ')
    parser.add_argument('--config', type=str, default='config.yaml',
                        help='ì„¤ì • íŒŒì¼ ê²½ë¡œ')
    parser.add_argument('--enable-failure-analysis', action='store_true',
                        help='ì‹¤íŒ¨ ì›ì¸ ë¶„ì„ í™œì„±í™”')
    
    args = parser.parse_args()
    
    # ë¡œê±° ë° ì„¤ì • ë¡œë“œ
    logger = setup_logger()
    config = load_config(args.config)
    
    # ëª¨ë“ˆ ì´ˆê¸°í™”
    ball_detector = BallDetector(config['vision']['ball_detection'])
    cue_detector = CueDetector(config['vision']['cue_detection'])
    physics_engine = PhysicsEngine(config['physics'])
    shot_generator = ShotGenerator(config['ranking'])
    shot_scorer = ShotScorer(config['ranking'])
    overlay_renderer = OverlayRenderer()
    
    # ì‹¤íŒ¨ ë¶„ì„ê¸° ì´ˆê¸°í™” (ì„ íƒì )
    failure_analyzer = None
    if args.enable_failure_analysis or args.mode == 'practice':
        failure_analyzer = FailureAnalyzer(config.get('failure_analysis', {}))
        logger.info("ì‹¤íŒ¨ ì›ì¸ ë¶„ì„ ëª¨ë“œ í™œì„±í™”")
    
    # ë¹„ë””ì˜¤ ì†ŒìŠ¤ ì„¤ì •
    if args.input:
        cap = cv2.VideoCapture(args.input)
    else:
        cap = cv2.VideoCapture(args.camera)
    
    logger.info(f"ì‹œìŠ¤í…œ ì‹œì‘ - ëª¨ë“œ: {args.mode}")
    
    # ìƒ· ì¶”ì ì„ ìœ„í•œ ë³€ìˆ˜
    previous_balls = None
    shot_in_progress = False
    expected_result = None
    shot_candidate = None
    
    while True:
        ret, frame = cap.read()
        if not ret:
            break
        
        # 1. ê³µ ê°ì§€
        current_balls = ball_detector.detect(frame)
        
        if args.mode == 'full' and len(current_balls) > 0:
            # 2. í ê°ì§€
            cue = cue_detector.detect(frame, current_balls)
            
            # ìƒ· ì‹œì‘ ê°ì§€ (íê°€ ì‚¬ë¼ì¡Œì„ ë•Œ)
            if previous_balls and cue is None and not shot_in_progress:
                shot_in_progress = True
                
                # 3. ìƒ· í›„ë³´ ìƒì„± ë° ìµœì  ìƒ· ì˜ˆì¸¡
                candidates = shot_generator.generate(current_balls, None)
                
                best_shot = None
                best_score = -1
                
                for candidate in candidates[:10]:
                    result = physics_engine.simulate(current_balls, candidate)
                    score = shot_scorer.score(result, candidate)
                    
                    if score > best_score:
                        best_score = score
                        best_shot = (candidate, result)
                
                if best_shot:
                    shot_candidate, expected_result = best_shot
                    logger.info(f"ìƒ· ì‹œì‘ ê°ì§€ - ì˜ˆìƒ ì ìˆ˜: {best_score:.2f}")
            
            # ìƒ· ì¢…ë£Œ ê°ì§€ (ëª¨ë“  ê³µì´ ì •ì§€í–ˆì„ ë•Œ)
            if shot_in_progress and self._balls_stopped(current_balls, previous_balls):
                shot_in_progress = False
                
                # ì‹¤íŒ¨ ë¶„ì„ ìˆ˜í–‰
                if failure_analyzer and expected_result:
                    # ì‹¤ì œ ê²°ê³¼ êµ¬ì„±
                    actual_result = {
                        'path': self._extract_cue_ball_path(previous_balls, current_balls),
                        'collisions': self._detect_collisions(previous_balls, current_balls),
                        'final_positions': [(b['x'], b['y']) for b in current_balls]
                    }
                    
                    # ë“ì  ì—¬ë¶€ í™•ì¸
                    success = self._check_scoring(expected_result, actual_result)
                    
                    if not success:
                        # ì‹¤íŒ¨ ì›ì¸ ë¶„ì„
                        analysis = failure_analyzer.analyze_failure(
                            expected_result,
                            actual_result,
                            shot_candidate
                        )
                        
                        # í”¼ë“œë°± ë©”ì‹œì§€ ìƒì„± ë° í‘œì‹œ
                        feedback_msg = failure_analyzer.generate_feedback_message(analysis)
                        logger.info(f"\nì‹¤íŒ¨ ë¶„ì„ ê²°ê³¼:\n{feedback_msg}")
                        
                        # í™”ë©´ì— í”¼ë“œë°± í‘œì‹œ
                        frame = self._display_failure_feedback(frame, feedback_msg, analysis)
                    else:
                        logger.info("âœ… ë“ì  ì„±ê³µ!")
                        frame = self._display_success_message(frame)
            
            # 4. ì‹œê°ì  í”¼ë“œë°±
            if expected_result and shot_candidate:
                frame = overlay_renderer.render(frame, current_balls, cue, 
                                                (shot_candidate, expected_result))
        else:
            # Vision ëª¨ë“œ: ê³µë§Œ í‘œì‹œ
            frame = overlay_renderer.render_balls(frame, current_balls)
        
        # í™”ë©´ í‘œì‹œ
        cv2.imshow('Billiard Coaching System', frame)
        
        # ì´ì „ í”„ë ˆì„ ì €ì¥
        previous_balls = current_balls
        
        # 'q' í‚¤ë¡œ ì¢…ë£Œ
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
    
    cap.release()
    cv2.destroyAllWindows()
    logger.info("ì‹œìŠ¤í…œ ì¢…ë£Œ")

    def _balls_stopped(self, current, previous, threshold=2.0):
        """ê³µë“¤ì´ ì •ì§€í–ˆëŠ”ì§€ í™•ì¸"""
        if not previous or len(current) != len(previous):
            return False
        
        for curr, prev in zip(current, previous):
            distance = np.sqrt((curr['x'] - prev['x'])**2 + (curr['y'] - prev['y'])**2)
            if distance > threshold:
                return False
        return True
    
    def _extract_cue_ball_path(self, start_balls, end_balls):
        """íë³¼ì˜ ì´ë™ ê²½ë¡œ ì¶”ì¶œ - ì˜ì‚¬ì½”ë“œ"""
        # TODO: í”„ë ˆì„ë³„ íë³¼ ìœ„ì¹˜ ì¶”ì  í•„ìš”
        # í˜„ì¬ëŠ” ì‹œì‘ê³¼ ë ìœ„ì¹˜ë§Œ ë°˜í™˜
        path = []
        # ... êµ¬í˜„ í•„ìš”
        return path
    
    def _detect_collisions(self, start_balls, end_balls):
        """ì¶©ëŒ ê°ì§€ - ì˜ì‚¬ì½”ë“œ"""
        # TODO: í”„ë ˆì„ë³„ ë¶„ì„ìœ¼ë¡œ ì¶©ëŒ ì§€ì  ê°ì§€
        collisions = []
        # ... êµ¬í˜„ í•„ìš”
        return collisions
    
    def _check_scoring(self, expected, actual):
        """ë“ì  ì—¬ë¶€ í™•ì¸ - ì˜ì‚¬ì½”ë“œ"""
        # TODO: í¬ì¼“ì— ë“¤ì–´ê°„ ê³µ í™•ì¸
        # ... êµ¬í˜„ í•„ìš”
        return False  # í˜„ì¬ëŠ” í•­ìƒ ì‹¤íŒ¨ë¡œ ê°€ì •
    
    def _display_failure_feedback(self, frame, message, analysis):
        """ì‹¤íŒ¨ í”¼ë“œë°±ì„ í™”ë©´ì— í‘œì‹œ"""
        overlay = frame.copy()
        
        # ë°˜íˆ¬ëª… ë°°ê²½
        cv2.rectangle(overlay, (10, 10), (600, 250), (0, 0, 0), -1)
        cv2.addWeighted(overlay, 0.7, frame, 0.3, 0, frame)
        
        # ë©”ì‹œì§€ í‘œì‹œ
        y_offset = 40
        for line in message.split('\n'):
            cv2.putText(frame, line, (20, y_offset),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 255), 2)
            y_offset += 30
        
        return frame
    
    def _display_success_message(self, frame):
        """ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ"""
        cv2.putText(frame, "SUCCESS!", (frame.shape[1]//2 - 100, frame.shape[0]//2),
                   cv2.FONT_HERSHEY_SIMPLEX, 2, (0, 255, 0), 4)
        return frame

if __name__ == '__main__':
    main()
```

---

### 17. ì‹¤íŒ¨ ë¶„ì„ ê²°ê³¼ ì˜ˆì‹œ

```
âŒ íŒŒì›Œê°€ 25.3% ë¶€ì¡±í–ˆìŠµë‹ˆë‹¤

ì¶”ê°€ ë¬¸ì œì :
  â€¢ í ê°ë„ê°€ 8.5Â° ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤
  â€¢ ì¶©ëŒ ì§€ì ì´ 3.2cm ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤

ğŸ’¡ ê°œì„  ë°©ì•ˆ:
  ğŸ’ª ìŠ¤íŠ¸ë¡œí¬ë¥¼ ì•½ 25% ë” ê°•í•˜ê²Œ í•´ë³´ì„¸ìš”
  ğŸ’¡ íë¥¼ 8.5Â° ë” ì˜¤ë¥¸ìª½ìœ¼ë¡œ í–¥í•˜ë„ë¡ ì¡°ì •í•˜ì„¸ìš”
  ğŸ“ ì¶©ëŒ ì§€ì ì„ 3.2cm ì¡°ì •í•´ì•¼ í•©ë‹ˆë‹¤
```

---

### 18. config.yaml ì—…ë°ì´íŠ¸ - ì‹¤íŒ¨ ë¶„ì„ ì„¤ì • ì¶”ê°€

```yaml
vision:
  ball_detection:
    min_radius: 5
    max_radius: 30
    confidence_threshold: 0.7
  
  cue_detection:
    min_length: 50
    angle_tolerance: 5

physics:
  friction_coefficient: 0.02
  restitution: 0.95
  simulation_steps: 1000
  time_delta: 0.001
  table_width: 254
  table_height: 127

ranking:
  angle_resolution: 15
  power_levels: [0.3, 0.5, 0.7, 1.0]
  weights:
    collision: 0.5
    accuracy: 0.3
    safety: 0.2

failure_analysis:
  enabled: true
  thresholds:
    angle_error: 10.0      # ê°ë„ ì˜¤ì°¨ ì„ê³„ê°’ (ë„)
    power_shortage: 0.2    # íŒŒì›Œ ë¶€ì¡± ë¹„ìœ¨
    power_excess: 0.3      # íŒŒì›Œ ê³¼ë‹¤ ë¹„ìœ¨
    near_miss: 5.0         # ê·¼ì ‘ ì‹¤íŒ¨ ê±°ë¦¬ (cm)
    cushion_error: 15.0    # ì¿ ì…˜ ê°ë„ ì˜¤ì°¨
  
  feedback:
    show_visual_hints: true    # ì‹œê°ì  íŒíŠ¸ í‘œì‹œ
    voice_feedback: false      # ìŒì„± í”¼ë“œë°± (ë¯¸êµ¬í˜„)
    save_failure_logs: true    # ì‹¤íŒ¨ ë¡œê·¸ ì €ì¥
```

---

### 19. ì‹¤íŒ¨ ë¶„ì„ ì•Œê³ ë¦¬ì¦˜ ìƒì„¸ ì„¤ëª…

#### ğŸ” ë¶„ì„ í”„ë¡œì„¸ìŠ¤

```
1. ë°ì´í„° ìˆ˜ì§‘ ë‹¨ê³„
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ - ì˜ˆìƒ ê²°ê³¼ (ì‹œë®¬ë ˆì´ì…˜)        â”‚
   â”‚ - ì‹¤ì œ ê²°ê³¼ (ì¹´ë©”ë¼ ì¶”ì )       â”‚
   â”‚ - ìƒ· ì…ë ¥ ì •ë³´                  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†“
2. ë¹„êµ ë¶„ì„ ë‹¨ê³„
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ â‘  ê°ë„ ì˜¤ì°¨ ê³„ì‚°                â”‚
   â”‚ â‘¡ íŒŒì›Œ ì˜¤ì°¨ ê³„ì‚°                â”‚
   â”‚ â‘¢ ì¶©ëŒ ì§€ì  ì°¨ì´ ë¶„ì„           â”‚
   â”‚ â‘£ ê²½ë¡œ í¸ì°¨ ë¶„ì„                â”‚
   â”‚ â‘¤ ìµœì¢… ìœ„ì¹˜ ë¹„êµ                â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†“
3. ì›ì¸ ë„ì¶œ ë‹¨ê³„
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ - ê° ì˜¤ì°¨ì˜ ì‹¬ê°ë„ ì ìˆ˜í™”       â”‚
   â”‚ - ì£¼ìš” ì›ì¸ / ë¶€ì°¨ ì›ì¸ ë¶„ë¥˜    â”‚
   â”‚ - ì˜¤ì°¨ ê°„ ìƒê´€ê´€ê³„ ë¶„ì„         â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†“
4. í”¼ë“œë°± ìƒì„± ë‹¨ê³„
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ - ì‚¬ìš©ì ì¹œí™”ì  ë©”ì‹œì§€ ìƒì„±     â”‚
   â”‚ - êµ¬ì²´ì  ê°œì„  ë°©ì•ˆ ì œì‹œ         â”‚
   â”‚ - ì‹œê°ì  ê°€ì´ë“œ ìƒì„±            â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ“Š ì›ì¸ ë¶„ì„ ì•Œê³ ë¦¬ì¦˜

**1. ê°ë„ ì˜¤ì°¨ ë¶„ì„**
```
ì…ë ¥: ì˜ˆìƒ ê°ë„, ì‹¤ì œ ì´ë™ ë²¡í„°
ì²˜ë¦¬:
  - ì‹¤ì œ ì´ë™ ë°©í–¥ì„ ë²¡í„°ë¡œ ê³„ì‚°
  - arctan2ë¡œ ê°ë„ ë³€í™˜
  - ì˜ˆìƒ ê°ë„ì™€ì˜ ì°¨ì´ ê³„ì‚°
ì¶œë ¥: ê°ë„ ì˜¤ì°¨ (ë„), ì¡°ì • ë°©í–¥
```

**2. íŒŒì›Œ ì˜¤ì°¨ ë¶„ì„**
```
ì…ë ¥: ì˜ˆìƒ ê²½ë¡œ, ì‹¤ì œ ê²½ë¡œ
ì²˜ë¦¬:
  - ê° ê²½ë¡œì˜ ì´ ì´ë™ê±°ë¦¬ ê³„ì‚°
  - ê±°ë¦¬ ë¹„ìœ¨ë¡œ íŒŒì›Œ ì˜¤ì°¨ ì¶”ì •
  - ì„ê³„ê°’ê³¼ ë¹„êµí•˜ì—¬ ë¶€ì¡±/ê³¼ë‹¤ íŒë‹¨
ì¶œë ¥: íŒŒì›Œ ì˜¤ì°¨ ë¹„ìœ¨, ì¡°ì •ëŸ‰
```

**3. ì¶©ëŒ ì§€ì  ë¶„ì„**
```
ì…ë ¥: ì˜ˆìƒ ì¶©ëŒì , ì‹¤ì œ ì¶©ëŒì 
ì²˜ë¦¬:
  - ìœ í´ë¦¬ë“œ ê±°ë¦¬ ê³„ì‚°
  - ì¶©ëŒ ê°ë„ ë¹„êµ
  - ì¶©ëŒ ì‹¤íŒ¨ ì—¬ë¶€ í™•ì¸
ì¶œë ¥: ê±°ë¦¬ ì˜¤ì°¨, ê°ë„ ì˜¤ì°¨
```

**4. ì¿ ì…˜ í™œìš© ë¶„ì„ (ë¯¸êµ¬í˜„ - ì•Œê³ ë¦¬ì¦˜)**
```
ì•Œê³ ë¦¬ì¦˜:
  1. ì¿ ì…˜ ì¶©ëŒ íšŸìˆ˜ ì¹´ìš´íŠ¸
     - ì˜ˆìƒ: NíšŒ
     - ì‹¤ì œ: MíšŒ
  
  2. ê° ì¿ ì…˜ ì¶©ëŒì˜ ì…ì‚¬ê°/ë°˜ì‚¬ê° ê³„ì‚°
     - ì´ìƒì  ë°˜ì‚¬ê° = 180Â° - ì…ì‚¬ê°
     - ì‹¤ì œ ë°˜ì‚¬ê°ê³¼ ë¹„êµ
  
  3. ì¿ ì…˜ í™œìš© ì‹¤íŒ¨ ìœ í˜• ë¶„ë¥˜
     - Type A: ì¿ ì…˜ ë¯¸ë„ë‹¬
     - Type B: ì¿ ì…˜ ê°ë„ ì˜¤ì°¨
     - Type C: ì¿ ì…˜ ê³¼ë„ ì¶©ëŒ
  
  4. ì›ì¸ íŒŒì•…
     - íŒŒì›Œ ë¶€ì¡± â†’ Type A
     - ê°ë„ ì˜¤ì°¨ â†’ Type B
     - íŒŒì›Œ ê³¼ë‹¤ â†’ Type C
```

**5. ìŠ¤í•€ íš¨ê³¼ ë¶„ì„ (ë¯¸êµ¬í˜„ - ì•Œê³ ë¦¬ì¦˜)**
```
ì•Œê³ ë¦¬ì¦˜:
  1. íƒ€ì (Impact Point) ì¶”ì •
     - íë³¼ ì¤‘ì‹¬ìœ¼ë¡œë¶€í„°ì˜ íƒ€ê²© ìœ„ì¹˜
     - Top/Bottom/Left/Right spin íŒë‹¨
  
  2. ìŠ¤í•€ìœ¼ë¡œ ì¸í•œ ê²½ë¡œ ë³€í™” ì˜ˆì¸¡
     - Top spin: ì¿ ì…˜ í›„ ê°€ì†
     - Back spin: ì¿ ì…˜ í›„ ê°ì†/ì—­íšŒì „
     - Side spin: ì¿ ì…˜ ê°ë„ ë³€í™”
  
  3. ì˜ˆìƒ vs ì‹¤ì œ ìŠ¤í•€ íš¨ê³¼ ë¹„êµ
     - ê²½ë¡œ ê³¡ë¥  ë¹„êµ
     - ì¿ ì…˜ ë°˜ì‚¬ ê°ë„ ë¹„êµ
  
  4. ìŠ¤í•€ ì˜¤ì°¨ íŒë‹¨
     - ê³¼ë„í•œ ìŠ¤í•€
     - ë¶ˆì¶©ë¶„í•œ ìŠ¤í•€
     - ì˜ëª»ëœ ìŠ¤í•€ ë°©í–¥
```

---

### 20. ì‹¤íŒ¨ ë¶„ì„ ì‹œê°í™” (ì˜ì‚¬ì½”ë“œ)

```python
"""
ì‹¤íŒ¨ ì›ì¸ì„ ì‹œê°ì ìœ¼ë¡œ í‘œì‹œí•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
"""

class FailureVisualizer:
    """ì‹¤íŒ¨ ì›ì¸ ì‹œê°í™” í´ë˜ìŠ¤"""
    
    def visualize_angle_error(self, frame, analysis):
        """
        ê°ë„ ì˜¤ì°¨ ì‹œê°í™”
        
        ì•Œê³ ë¦¬ì¦˜:
        1. ì˜ˆìƒ ê°ë„ë¥¼ ë…¹ìƒ‰ í™”ì‚´í‘œë¡œ í‘œì‹œ
        2. ì‹¤ì œ ê°ë„ë¥¼ ë¹¨ê°„ìƒ‰ í™”ì‚´í‘œë¡œ í‘œì‹œ
        3. ë‘ í™”ì‚´í‘œ ì‚¬ì´ì— í˜¸(arc)ë¡œ ì˜¤ì°¨ ê°ë„ í‘œì‹œ
        4. ìˆ˜ì • ë°©í–¥ì„ ì ì„  í™”ì‚´í‘œë¡œ ê°€ì´ë“œ
        """
        pass
    
    def visualize_power_error(self, frame, analysis):
        """
        íŒŒì›Œ ì˜¤ì°¨ ì‹œê°í™”
        
        ì•Œê³ ë¦¬ì¦˜:
        1. ì˜ˆìƒ ê²½ë¡œë¥¼ ë…¹ìƒ‰ ì„ ìœ¼ë¡œ í‘œì‹œ
        2. ì‹¤ì œ ê²½ë¡œë¥¼ ë¹¨ê°„ìƒ‰ ì„ ìœ¼ë¡œ í‘œì‹œ
        3. ê²½ë¡œ ëì§€ì ì— ê²Œì´ì§€ ë°” í‘œì‹œ
           - ë¶€ì¡±: ë¹¨ê°„ìƒ‰ (â†“)
           - ê³¼ë‹¤: ì£¼í™©ìƒ‰ (â†‘)
        4. í•„ìš”í•œ íŒŒì›Œ ì¡°ì •ëŸ‰ì„ í…ìŠ¤íŠ¸ë¡œ í‘œì‹œ
        """
        pass
    
    def visualize_collision_miss(self, frame, analysis):
        """
        ì¶©ëŒ ë¯¸ìŠ¤ ì‹œê°í™”
        
        ì•Œê³ ë¦¬ì¦˜:
        1. ëª©í‘œ ì¶©ëŒ ì§€ì ì„ ë…¹ìƒ‰ ì›ìœ¼ë¡œ í‘œì‹œ
        2. ì‹¤ì œ íë³¼ ê²½ë¡œë¥¼ ì¶”ì ì„ ìœ¼ë¡œ í‘œì‹œ
        3. ëª©í‘œê³µê³¼ ìµœë‹¨ê±°ë¦¬ ì§€ì  í‘œì‹œ
        4. ë³´ì • ë°©í–¥ì„ í™”ì‚´í‘œë¡œ ê°€ì´ë“œ
        """
        pass
    
    def overlay_improvement_guide(self, frame, recommendations):
        """
        ê°œì„  ê°€ì´ë“œ ì˜¤ë²„ë ˆì´
        
        ì•Œê³ ë¦¬ì¦˜:
        1. í™”ë©´ ìƒë‹¨ì— ë°˜íˆ¬ëª… íŒ¨ë„ ìƒì„±
        2. ì£¼ìš” ì›ì¸ì„ ì•„ì´ì½˜ê³¼ í•¨ê»˜ í‘œì‹œ
        3. ê°œì„  ë°©ì•ˆì„ ë²ˆí˜¸ ìˆœì„œëŒ€ë¡œ ë‚˜ì—´
        4. ì‹¬ê°ë„ì— ë”°ë¼ ìƒ‰ìƒ êµ¬ë¶„
           - Low: ì´ˆë¡ìƒ‰
           - Medium: ë…¸ë€ìƒ‰
           - High: ë¹¨ê°„ìƒ‰
        """
        pass
```

---

### 21. ì—°ìŠµ ëª¨ë“œ êµ¬í˜„ (ì•Œê³ ë¦¬ì¦˜)

```python
"""
ë°˜ë³µ ì—°ìŠµ ë° í•™ìŠµ ëª¨ë“œ
"""

class PracticeMode:
    """ì—°ìŠµ ëª¨ë“œ ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.shot_history = []
        self.improvement_tracker = {}
    
    def run_practice_session(self, target_skill):
        """
        íŠ¹ì • ê¸°ìˆ  ì§‘ì¤‘ ì—°ìŠµ
        
        ì•Œê³ ë¦¬ì¦˜:
        1. ëª©í‘œ ì„¤ì •
           - ê°ë„ ì •í™•ë„ í–¥ìƒ
           - íŒŒì›Œ ì¡°ì ˆ ì—°ìŠµ
           - ì¿ ì…˜ ìƒ· ì—°ìŠµ
        
        2. ë°˜ë³µ ì‹œë„
           for each attempt:
               - ìƒ· ì‹¤í–‰
               - ì‹¤ì‹œê°„ í”¼ë“œë°±
               - ì„±ê³µ/ì‹¤íŒ¨ ê¸°ë¡
        
        3. ì§„í–‰ ìƒí™© ë¶„ì„
           - ì‹œë„ë³„ ì ìˆ˜ ë³€í™” ê·¸ë˜í”„
           - ì£¼ìš” ì˜¤ì°¨ í•­ëª© í†µê³„
           - ê°œì„  ì¶”ì„¸ ê³„ì‚°
        
        4. ë§ì¶¤í˜• ì¡°ì–¸
           - ì·¨ì•½ì  ê¸°ë°˜ ì—°ìŠµ ê³¼ì œ ì œì•ˆ
           - ë‹¤ìŒ ë‚œì´ë„ ë‹¨ê³„ ì¶”ì²œ
        """
        pass
    
    def analyze_progress(self, history):
        """
        í•™ìŠµ ì§„í–‰ë„ ë¶„ì„
        
        ì•Œê³ ë¦¬ì¦˜:
        1. ìµœê·¼ Nê°œ ìƒ·ì˜ í†µê³„ ìˆ˜ì§‘
           - í‰ê·  ì ìˆ˜
           - ì„±ê³µë¥ 
           - ì£¼ìš” ì˜¤ì°¨ ë¹ˆë„
        
        2. ì‹œê°„ëŒ€ë³„ ì„±ëŠ¥ ë³€í™” ì¶”ì 
           - ì´ˆê¸° vs ìµœê·¼ ë¹„êµ
           - í•™ìŠµ ê³¡ì„  ê·¸ë˜í”„
        
        3. ê°•ì /ì•½ì  ë¶„ì„
           - ì˜í•˜ëŠ” ìƒ· ìœ í˜• ì‹ë³„
           - ë°˜ë³µë˜ëŠ” ì‹¤ìˆ˜ íŒ¨í„´ ë°œê²¬
        
        4. ëª©í‘œ ë‹¬ì„±ë„ í‰ê°€
           - ì„¤ì •í•œ ëª©í‘œ ëŒ€ë¹„ í˜„ì¬ ìˆ˜ì¤€
           - ë‹¤ìŒ ë§ˆì¼ìŠ¤í†¤ê¹Œì§€ í•„ìš”í•œ ì—°ìŠµëŸ‰
        """
        pass
    
    def generate_custom_drill(self, weakness):
        """
        ë§ì¶¤í˜• ì—°ìŠµ ê³¼ì œ ìƒì„±
        
        ì•Œê³ ë¦¬ì¦˜:
        1. ì•½ì  ì‹ë³„
           - ê°ë„ ì¡°ì ˆ ì•½í•¨
           - íŒŒì›Œ ì¡°ì ˆ ì•½í•¨
           - ì¿ ì…˜ í™œìš© ì•½í•¨
        
        2. ë‚œì´ë„ ì¡°ì •
           - í˜„ì¬ ìˆ˜ì¤€ í‰ê°€
           - ì ì • ë„ì „ ê³¼ì œ ì„ ì •
        
        3. ì—°ìŠµ ì‹œë‚˜ë¦¬ì˜¤ êµ¬ì„±
           - ê³µ ë°°ì¹˜ ì„¤ì •
           - ëª©í‘œ ë‹¬ì„± ì¡°ê±´
           - ì œí•œ ì‹œê°„/ì‹œë„ íšŸìˆ˜
        
        4. ì ì§„ì  ë‚œì´ë„ ì¦ê°€
           - ì„±ê³µ ì‹œ ë” ì–´ë ¤ìš´ ê³¼ì œ
           - ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ìœ¼ë¡œ ë³µê·€
        """
        pass
```

---

### 22. ë°ì´í„° ê¸°ë°˜ í•™ìŠµ ê°œì„  (ë¯¸ë˜ ê¸°ëŠ¥ - ì»¨ì…‰)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ ì„±ëŠ¥ ì˜ˆì¸¡ ëª¨ë¸       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  ì…ë ¥: ì‚¬ìš©ìì˜ ê³¼ê±° ìƒ· ë°ì´í„°          â”‚
â”‚    - ê°ë„ ì˜¤ì°¨ íŒ¨í„´                     â”‚
â”‚    - íŒŒì›Œ ì¡°ì ˆ ê²½í–¥                     â”‚
â”‚    - ìì£¼ í•˜ëŠ” ì‹¤ìˆ˜ ìœ í˜•                â”‚
â”‚                                         â”‚
â”‚  ì²˜ë¦¬: ML ëª¨ë¸                          â”‚
â”‚    - íŒ¨í„´ ì¸ì‹                          â”‚
â”‚    - ì˜ˆì¸¡ ëª¨ë¸ë§                        â”‚
â”‚    - í´ëŸ¬ìŠ¤í„°ë§                         â”‚
â”‚                                         â”‚
â”‚  ì¶œë ¥: ë§ì¶¤í˜• ì½”ì¹­                      â”‚
â”‚    - ê°œì¸í™”ëœ ë‚œì´ë„ ì¡°ì •               â”‚
â”‚    - ì˜ˆì¸¡ ê¸°ë°˜ ì‚¬ì „ ê²½ê³                 â”‚
â”‚    - ìµœì  í•™ìŠµ ê²½ë¡œ ì œì•ˆ                â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ–¼ï¸ ê²°ê³¼ í™”ë©´ ì˜ˆì‹œ

ì‹œìŠ¤í…œì´ ì‹¤í–‰ë˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ í™”ë©´ì´ í‘œì‹œë©ë‹ˆë‹¤:

### ì„±ê³µ ì‹œ í™”ë©´
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Billiard Coaching System                   â”‚
â”‚  Angle: 45.0Â° | Power: 0.70 | Score: 0.85   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                             â”‚
â”‚     â—  â† í°ê³µ (íë³¼)                        â”‚
â”‚      \                                      â”‚
â”‚       \  â† ì˜ˆìƒ ê²½ë¡œ (ë…¸ë€ìƒ‰ ì„ )             â”‚
â”‚        \                                    â”‚
â”‚         â—  â† ëª©í‘œê³µ (ë¹¨ê°„ìƒ‰)                 â”‚
â”‚                                             â”‚
â”‚         âŠ—  â† ì¶©ëŒ ì§€ì                        â”‚
â”‚                                             â”‚
â”‚    â”â”â”â”  â† í (ë³´ë¼ìƒ‰ ì„ )                    â”‚
â”‚                                             â”‚
â”‚  âœ… SUCCESS! ë“ì  ì„±ê³µ                       â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ì‹¤íŒ¨ ì‹œ í™”ë©´ (í”¼ë“œë°± í¬í•¨)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Billiard Coaching System                   â”‚
â”‚  Angle: 48.5Â° | Power: 0.55 | Score: 0.32   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                             â”‚
â”‚  âŒ ì‹¤íŒ¨ ì›ì¸ ë¶„ì„                           â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•    â”‚
â”‚                                             â”‚
â”‚  ì£¼ìš” ì›ì¸:                                  â”‚
â”‚  ğŸ’ª íŒŒì›Œê°€ 25.3% ë¶€ì¡±í–ˆìŠµë‹ˆë‹¤               â”‚
â”‚                                             â”‚
â”‚  ì¶”ê°€ ë¬¸ì œ:                                  â”‚
â”‚  â€¢ í ê°ë„ê°€ 8.5Â° ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤              â”‚
â”‚  â€¢ ì¶©ëŒ ì§€ì ì´ 3.2cm ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤           â”‚
â”‚                                             â”‚
â”‚  ğŸ’¡ ê°œì„  ë°©ì•ˆ:                               â”‚
â”‚  1. ìŠ¤íŠ¸ë¡œí¬ë¥¼ 25% ë” ê°•í•˜ê²Œ í•´ë³´ì„¸ìš”       â”‚
â”‚  2. íë¥¼ 8.5Â° ë” ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì¡°ì •í•˜ì„¸ìš”      â”‚
â”‚  3. ì¡°ì¤€ì„ 3.2cm ì™¼ìª½ìœ¼ë¡œ ì´ë™í•˜ì„¸ìš”        â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[ë¡œê·¸ ì¶œë ¥]
2024-01-15 10:30:45 - INFO - ì‹œìŠ¤í…œ ì‹œì‘
2024-01-15 10:30:46 - INFO - ê³µ 3ê°œ ê°ì§€ë¨
2024-01-15 10:30:47 - INFO - ìƒ· ì‹¤í–‰ ê°ì§€
2024-01-15 10:30:48 - WARN - ë“ì  ì‹¤íŒ¨
2024-01-15 10:30:48 - INFO - ì‹¤íŒ¨ ì›ì¸ ë¶„ì„ ì™„ë£Œ
```

---

## ğŸ—ºï¸ ê°œë°œ ë¡œë“œë§µ

| ë‹¨ê³„ | ì£¼ìš” ëª©í‘œ | ì„¸ë¶€ ë‚´ìš© |
|------|-----------|-----------|
| 1ï¸âƒ£ Prototype êµ¬ì¶• | ê¸°ë³¸ êµ¬ì¡° ì™„ì„± | ê³µ ì¶”ì  MVP, í ê°ë„ ì¶”ì • |
| 2ï¸âƒ£ Physics Engine ê³ ë„í™” | ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì •í™•ë„ í–¥ìƒ | ì¶©ëŒ, ë§ˆì°°, ì¿ ì…˜ ë°˜ì‚¬ êµ¬í˜„ |
| 3ï¸âƒ£ Ranking System êµ¬í˜„ | ìƒ· í›„ë³´ ìƒì„± ë° í‰ê°€ | ì ìˆ˜í™” ì•Œê³ ë¦¬ì¦˜ ë° ìµœì í™” |
| 4ï¸âƒ£ Feedback UI í†µí•© | ì‹œê°ì  ì˜¤ë²„ë ˆì´ ì¶”ê°€ | ê²½ë¡œ ì˜ˆì¸¡ ë° ì‹¤ì‹œê°„ ë Œë”ë§ |
| 5ï¸âƒ£ **ì‹¤íŒ¨ ë¶„ì„ ì‹œìŠ¤í…œ** âœ¨ | **ì›ì¸ ì§„ë‹¨ ë° í”¼ë“œë°±** | **ê°ë„/íŒŒì›Œ/ì¶©ëŒ ì˜¤ì°¨ ë¶„ì„, ê°œì„  ë°©ì•ˆ ì œì‹œ** |
| 6ï¸âƒ£ í”„ë¼ì´ë²„ì‹œ ê°•í™” | ë¡œì»¬ ì €ì¥ ë° ìµëª…í™” | ë°ì´í„° ë³´í˜¸ ì •ì±… êµ¬í˜„ |
| 7ï¸âƒ£ ì—°ìŠµ ëª¨ë“œ ì¶”ê°€ | í•™ìŠµ ì§„í–‰ë„ ì¶”ì  | ë§ì¶¤í˜• ì—°ìŠµ ê³¼ì œ, í†µê³„ ë¶„ì„ |
| 8ï¸âƒ£ ë‹¤ì¤‘ í”Œë«í¼ ì§€ì› | ì›¹/ë°ìŠ¤í¬íƒ‘/ëª¨ë°”ì¼ í™•ì¥ | React ê¸°ë°˜ ì›¹ UI ê°œë°œ |
| 9ï¸âƒ£ ì„±ëŠ¥ ìµœì í™” | ì‹¤ì‹œê°„ ì²˜ë¦¬ ê°œì„  | GPU ê°€ì†, í”„ë ˆì„ë ˆì´íŠ¸ í–¥ìƒ |
| ğŸ”Ÿ ì»¤ë®¤ë‹ˆí‹° ê³µê°œ | ì˜¤í”ˆì†ŒìŠ¤ ë°°í¬ | ë¬¸ì„œí™”, API/SDK ê³µê°œ |# ğŸ± Camera-Based Real-time Billiard Shot Coaching System
---

## ğŸ—ï¸ ì•„í‚¤í…ì²˜

### ì‹œìŠ¤í…œ êµ¬ì„±ë„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Camera    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Vision Module      â”‚
â”‚  - Ball Detection    â”‚
â”‚  - Cue Detection     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Physics Simulation   â”‚
â”‚  - Collision         â”‚
â”‚  - Friction & Spin   â”‚
â”‚  - Cushion Bounce    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Ranking Engine      â”‚
â”‚  - Generate Shots    â”‚
â”‚  - Score & Rank      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Feedback Engine     â”‚
â”‚  - Visual Overlay    â”‚
â”‚  - Text Feedback     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ë°ì´í„° íë¦„

1. **ì¹´ë©”ë¼ ì…ë ¥** â†’ ì‹¤ì‹œê°„ í”„ë ˆì„ ìº¡ì²˜
2. **ë¹„ì „ ëª¨ë“ˆ** â†’ ê³µ/í ìœ„ì¹˜ ê°ì§€ ë° ì¶”ì 
3. **ìƒ· ìƒì„±** â†’ ê°€ëŠ¥í•œ ìƒ· í›„ë³´ ìƒì„± (ê°ë„ Ã— íŒŒì›Œ)
4. **ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜** â†’ ê° í›„ë³´ì— ëŒ€í•œ ê²½ë¡œ ì˜ˆì¸¡
5. **ì ìˆ˜ ê³„ì‚°** â†’ ì¶©ëŒ/ì •í™•ë„/ì•ˆì „ì„± ê¸°ë°˜ í‰ê°€
6. **í”¼ë“œë°± ë Œë”ë§** â†’ ìµœì  ìƒ· ì‹œê°í™” ë° í‘œì‹œ

---

## ğŸ–¼ï¸ ê²°ê³¼ í™”ë©´ ì˜ˆì‹œ

ì‹œìŠ¤í…œì´ ì‹¤í–‰ë˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ í™”ë©´ì´ í‘œì‹œë©ë‹ˆë‹¤:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Billiard Coaching System                   â”‚
â”‚  Angle: 45.0Â° | Power: 0.70                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                             â”‚
â”‚     â—  â† í°ê³µ (íë³¼)                        â”‚
â”‚      \                                      â”‚
â”‚       \  â† ì˜ˆìƒ ê²½ë¡œ (ë…¸ë€ìƒ‰ ì„ )             â”‚
â”‚        \                                    â”‚
â”‚         â—  â† ëª©í‘œê³µ (ë¹¨ê°„ìƒ‰)                 â”‚
â”‚                                             â”‚
â”‚         âŠ—  â† ì¶©ëŒ ì§€ì                        â”‚
â”‚                                             â”‚
â”‚    â”â”â”â”  â† í (ë³´ë¼ìƒ‰ ì„ )                    â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[ë¡œê·¸ ì¶œë ¥]
2024-01-15 10:30:45 - INFO - ì‹œìŠ¤í…œ ì‹œì‘ - ëª¨ë“œ: full
2024-01-15 10:30:46 - INFO - ê³µ 3ê°œ ê°ì§€ë¨
2024-01-15 10:30:46 - INFO - ìµœì  ìƒ· ê³„ì‚° ì™„ë£Œ (ì ìˆ˜: 0.85)
```

### í™”ë©´ êµ¬ì„± ìš”ì†Œ

- **í°ìƒ‰ ì›**: íë³¼ (í° ê³µ)
- **ë¹¨ê°„ìƒ‰/íŒŒë€ìƒ‰ ì›**: ëª©í‘œê³µë“¤
- **ë…¸ë€ìƒ‰ ì„ **: ì˜ˆìƒ ì¶©ëŒ ê²½ë¡œ
- **ë¹¨ê°„ìƒ‰ ì **: ì¶©ëŒ ì˜ˆìƒ ì§€ì 
- **ë³´ë¼ìƒ‰ ì„ **: í ìŠ¤í‹± ìœ„ì¹˜
- **ìƒë‹¨ í…ìŠ¤íŠ¸**: ì¶”ì²œ ê°ë„ ë° íŒŒì›Œ

---


## ğŸ¤ ê¸°ì—¬í•˜ê¸°

ê¸°ì—¬ë¥¼ í™˜ì˜í•©ë‹ˆë‹¤! ë‹¤ìŒ ì ˆì°¨ë¥¼ ë”°ë¼ì£¼ì„¸ìš”:

1. ì´ ì €ì¥ì†Œë¥¼ Fork í•©ë‹ˆë‹¤
2. Feature ë¸Œëœì¹˜ë¥¼ ìƒì„±í•©ë‹ˆë‹¤ (`git checkout -b feature/AmazingFeature`)
3. ë³€ê²½ì‚¬í•­ì„ ì»¤ë°‹í•©ë‹ˆë‹¤ (`git commit -m 'Add some AmazingFeature'`)
4. ë¸Œëœì¹˜ì— Push í•©ë‹ˆë‹¤ (`git push origin feature/AmazingFeature`)
5. Pull Requestë¥¼ ìƒì„±í•©ë‹ˆë‹¤

### ê¸°ì—¬ ê°€ëŠ¥í•œ ì˜ì—­

- âœ… ì´ë¯¸ êµ¬í˜„ëœ ê¸°ëŠ¥ ê°œì„ 
  - ê³µ/í ê°ì§€ ì •í™•ë„ í–¥ìƒ
  - ë¬¼ë¦¬ ì—”ì§„ ìµœì í™”
  - ì‹¤íŒ¨ ë¶„ì„ ì•Œê³ ë¦¬ì¦˜ ê³ ë„í™”
  
- ğŸ”¨ êµ¬í˜„ í•„ìš” (ì˜ì‚¬ì½”ë“œë§Œ ì œê³µë¨)
  - ì¿ ì…˜ í™œìš© ë¶„ì„ (`feedback/failure_analyzer.py`)
  - ìŠ¤í•€ íš¨ê³¼ ë¶„ì„ (`feedback/failure_analyzer.py`)
  - ì‹¤íŒ¨ ì‹œê°í™” (`feedback/failure_visualizer.py`)
  - ì—°ìŠµ ëª¨ë“œ (`practice/practice_mode.py`)
  - í•™ìŠµ ì§„í–‰ë„ ì¶”ì  ì‹œìŠ¤í…œ


ìì„¸í•œ ë‚´ìš©ì€ [CONTRIBUTING.md](CONTRIBUTING.md)ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”.

---

## ğŸ“„ ë¼ì´ì„ ìŠ¤

ë³¸ í”„ë¡œì íŠ¸ì˜ ì½”ë“œëŠ” **MIT License**ë¥¼ ë”°ë¦…ë‹ˆë‹¤.

---

## ğŸ’¡ í–¥í›„ ê°œë°œ ë°©í–¥

### ë‹¨ê¸° ëª©í‘œ (1ê°œì›”)
- [ ] ì¿ ì…˜ ë°˜ì‚¬ ì™„ì „ êµ¬í˜„
- [ ] ìŠ¤í•€ íš¨ê³¼ ì‹œë®¬ë ˆì´ì…˜
- [ ] ì—°ìŠµ ëª¨ë“œ ë² íƒ€ ë²„ì „
- [ ] ì„±ëŠ¥ ìµœì í™” (60fps ì•ˆì •í™”)

### ì¤‘ê¸° ëª©í‘œ (1ë…„)
- [ ] ì›¹ ê¸°ë°˜ UI ê°œë°œ
- [ ] ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ ìƒ· ì˜ˆì¸¡
- [ ] ë‹¤ì–‘í•œ ê²Œì„ ë£° ì§€ì›
- [ ] ëª¨ë°”ì¼ ì•± í”„ë¡œí† íƒ€ì…

### ì¥ê¸° ëª©í‘œ (1ë…„+)
- [ ] AR ê¸°ë°˜ ì‹¤ì‹œê°„ ê°€ì´ë“œ
- [ ] ì˜¨ë¼ì¸ ì½”ì¹­ í”Œë«í¼
- [ ] í”„ë¡œ ì„ ìˆ˜ ë°ì´í„° ë¶„ì„
- [ ] êµ­ì œ ëŒ€íšŒ í™œìš©

---

## ğŸ™ ì°¸ê³  ìë£Œ

### ê´€ë ¨ í”„ë¡œì íŠ¸
- [Open Shot Detector](https://github.com/honey-da/osd.git) - ë©€í‹° AI ëª¨ë¸ ë¼ìš°íŒ… ì‹œìŠ¤í…œ

### ê¸°ìˆ  ë¬¸ì„œ
- [OpenCV ë¬¸ì„œ](https://docs.opencv.org/)
- [ë‹¹êµ¬ ë¬¼ë¦¬í•™](https://billiards.colostate.edu/)
- [Hough Transform](https://en.wikipedia.org/wiki/Hough_transform)

### ë…¼ë¬¸ ë° ì—°êµ¬
- "Computer Vision for Billiard Analysis" (2023)
- "Real-time Physics Simulation for Sports Coaching" (2022)

---

## ğŸ“ ì‚¬ìš© ì˜ˆì‹œ ë° íŠœí† ë¦¬ì–¼

### ê¸°ë³¸ ì‚¬ìš©ë²•
```bash
# 1. ì €ì¥ì†Œ í´ë¡ 
git clone https://github.com/your-username/billiard-coaching-system.git
cd billiard-coaching-system

# 2. í™˜ê²½ ì„¤ì •
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
pip install -r requirements.txt

# 3. ê¸°ë³¸ ì‹¤í–‰
python main.py --mode full --camera 0

# 4. ì‹¤íŒ¨ ë¶„ì„ ëª¨ë“œë¡œ ì‹¤í–‰
python main.py --mode practice --enable-failure-analysis

# 5. ë¹„ë””ì˜¤ íŒŒì¼ë¡œ í…ŒìŠ¤íŠ¸
python main.py --mode full --input examples/sample_videos/test.mp4
```

### ê³ ê¸‰ ì„¤ì •
```bash
# ì»¤ìŠ¤í…€ ì„¤ì • íŒŒì¼ ì‚¬ìš©
python main.py --config my_config.yaml

# ë””ë²„ê·¸ ëª¨ë“œ
DEBUG_MODE=true python main.py --mode full
```

---

## âš ï¸ ì•Œë ¤ì§„ ì œí•œì‚¬í•­

í˜„ì¬ ë²„ì „ì˜ ì œí•œì‚¬í•­:

- ì¡°ëª… ì¡°ê±´ì— ë”°ë¼ ê³µ ê°ì§€ ì •í™•ë„ê°€ ë³€ë™ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ë³µì¡í•œ ìŠ¤í•€ íš¨ê³¼ëŠ” ì•„ì§ ì‹œë®¬ë ˆì´ì…˜ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤
- ì‹¤ì‹œê°„ ê²½ë¡œ ì¶”ì  ê¸°ëŠ¥ì´ ë¯¸êµ¬í˜„ ìƒíƒœì…ë‹ˆë‹¤ (í”„ë ˆì„ ê°„ ë³´ê°„ í•„ìš”)
- ì¿ ì…˜ ë°˜ì‚¬ ë¬¼ë¦¬ ëª¨ë¸ì´ ë‹¨ìˆœí™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤

ê°œì„  ê³„íšì€ [ë¡œë“œë§µ](#-ê°œë°œ-ë¡œë“œë§µ)ì„ ì°¸ì¡°í•˜ì„¸ìš”.

---

## ğŸ”§ íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

### ê³µì´ ê°ì§€ë˜ì§€ ì•ŠëŠ” ê²½ìš°
```yaml
# config.yaml ì¡°ì •
vision:
  ball_detection:
    min_radius: 3        # ë” ì‘ì€ ê°’ìœ¼ë¡œ ì¡°ì •
    max_radius: 40       # ë” í° ê°’ìœ¼ë¡œ ì¡°ì •
    confidence_threshold: 0.5  # ë‚®ì¶°ì„œ ê°ë„ ì¦ê°€
```

### FPSê°€ ë‚®ì€ ê²½ìš°
```bash
# í•´ìƒë„ ë‚®ì¶”ê¸°
python main.py --camera 0 --resolution 640x480

# ì‹œë®¬ë ˆì´ì…˜ ìŠ¤í… ì¤„ì´ê¸°
# config.yamlì—ì„œ simulation_steps: 500 ìœ¼ë¡œ ì¡°ì •
```

### ì‹¤íŒ¨ ë¶„ì„ì´ ì‘ë™í•˜ì§€ ì•ŠëŠ” ê²½ìš°
```bash
# ëª…ì‹œì ìœ¼ë¡œ í™œì„±í™”
python main.py --mode practice --enable-failure-analysis

# ë¡œê·¸ í™•ì¸
tail -f logs/billiard_*.log
```

---
